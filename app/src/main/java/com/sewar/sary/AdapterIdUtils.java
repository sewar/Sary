package com.sewar.sary;

import androidx.annotation.Nullable;

// From Epoxy

/**
 * Utilities for generating 64-bit long IDs from types such as {@link CharSequence}.
 */
public final class AdapterIdUtils {
    /**
     * Counts how many of these objects are created, so that each new object can have a unique id.
     * Uses negative values so that these autogenerated ids don't clash with database ids.
     */
    private static long idCounter = -1;


    private AdapterIdUtils() {
    }

    public static long id() {
        return idCounter--;
    }

    /**
     * Override the default id in cases where the data subject naturally has an id, like an object
     * from a database.
     */
    public static long id(long id) {
        return id;
    }

    /**
     * Use multiple numbers as the id for this model. Useful when you don't have a single long that
     * represents a unique id.
     * <p>
     * This hashes the numbers, so there is a tiny risk of collision with other ids.
     */
    public static long id(@Nullable Number... ids) {
        long result = 0;
        if (ids != null) {
            for (@Nullable Number id : ids) {
                result = 31 * result + hashLong64Bit(id == null ? 0 : id.hashCode());
            }
        }
        return id(result);
    }

    /**
     * Use two numbers as the id for this model. Useful when you don't have a single long that
     * represents a unique id.
     * <p>
     * This hashes the two numbers, so there is a tiny risk of collision with other ids.
     */
    public static long id(long id1, long id2) {
        long result = hashLong64Bit(id1);
        result = 31 * result + hashLong64Bit(id2);
        return id(result);
    }

    /**
     * Use a string as the model id. Useful for models that don't clearly map to a numerical id. This
     * is preferable to using {@link String#hashCode()} because that is a 32 bit hash and this is a 64
     * bit hash, giving better spread and less chance of collision with other ids.
     * <p>
     * Since this uses a hashcode method to convert the String to a long there is a very small chance
     * that you may have a collision with another id. Assuming an even spread of hashcodes, and
     * several hundred models in the adapter, there would be roughly 1 in 100 trillion chance of a
     * collision. (http://preshing.com/20110504/hash-collision-probabilities/)
     *
     * @see AdapterIdUtils#hashString64Bit(CharSequence)
     */
    public static long id(@Nullable CharSequence key) {
        return id(hashString64Bit(key));
    }

    /**
     * Use several strings to define the id of the model.
     * <p>
     * Similar to {@link #id(CharSequence)}, but with additional strings.
     */
    public static long id(@Nullable CharSequence key, @Nullable CharSequence... otherKeys) {
        long result = hashString64Bit(key);
        if (otherKeys != null) {
            for (CharSequence otherKey : otherKeys) {
                result = 31 * result + hashString64Bit(otherKey);
            }
        }
        return id(result);
    }

    /**
     * Set an id that is namespaced with a string. This is useful when you need to show models of
     * multiple types, side by side and don't want to risk id collisions.
     * <p>
     * Since this uses a hashcode method to convert the String to a long there is a very small chance
     * that you may have a collision with another id. Assuming an even spread of hashcodes, and
     * several hundred models in the adapter, there would be roughly 1 in 100 trillion chance of a
     * collision. (http://preshing.com/20110504/hash-collision-probabilities/)
     *
     * @see AdapterIdUtils#hashString64Bit(CharSequence)
     * @see AdapterIdUtils#hashLong64Bit(long)
     */
    public static long id(@Nullable CharSequence key, long id) {
        long result = hashString64Bit(key);
        result = 31 * result + hashLong64Bit(id);
        return id(result);
    }

    /**
     * Hash a long into 64 bits instead of the normal 32. This uses a xor shift implementation to
     * attempt psuedo randomness so object ids have an even spread for less chance of collisions.
     * <p>
     * From http://stackoverflow.com/a/11554034
     * <p>
     * http://www.javamex.com/tutorials/random_numbers/xorshift.shtml
     */
    public static long hashLong64Bit(long value) {
        value ^= (value << 21);
        value ^= (value >>> 35);
        value ^= (value << 4);
        return value;
    }

    /**
     * Hash a string into 64 bits instead of the normal 32. This allows us to better use strings as a
     * model id with less chance of collisions. This uses the FNV-1a algorithm for a good mix of speed
     * and distribution.
     * <p>
     * Performance comparisons found at http://stackoverflow.com/a/1660613
     * <p>
     * Hash implementation from http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-1a
     */
    public static long hashString64Bit(@Nullable CharSequence str) {
        if (str == null) {
            return 0;
        }

        long result = 0xcbf29ce484222325L;
        final int len = str.length();
        for (int i = 0; i < len; i++) {
            result ^= str.charAt(i);
            result *= 0x100000001b3L;
        }
        return result;
    }
}
